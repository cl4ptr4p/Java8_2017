# Java8_2017

## Домашнее задание № 1
### Задача 1
Написать программу, моделирующую следующий процесс.

Имеется поток (Thread), владеющий условным количеством ресурсов (скажем, дисковой памяти). Назовем этот поток сервером ресурса. Общее количество единиц ресурса является параметром программы и задается в конфигурационном файле, который считывается в начале работы. Имеется генератор запросов, которые поступают в случайные моменты времени. Каждый запрос - это отдельный поток, создаваемый генератором, который запрашивает определенное количество единиц ресурса, в течение некоторого случайного промежутка времени владеет им, и, наконец, возвращает ресурс и заканчивает работу. Сервер ресурса может отказать в выделении ресурса, если оставшихся единиц ресурса недостаточно, в этом случае поток, запросивший ресурс, заканчивает работу немедленно и не ждет освобождения ресурсов.

Сервер ресурса ведет протокол запросов, в котором отмечаются заявки, возвраты ресурса, отказы в предоставлении ресурса и т.д. Строки протокола содержат информацию о текущем времени и количестве оставшихся на данный момент единиц ресурса. Протокол записывается в файл, имя которого также задается в конфигурационном файле.

По истечении заданного количества времени работы (общее время работы также задается в конфигурационном файле) сервер подает сигнал о прекращении обработки заявок на ресурсы (генератор запросов перестает генерировать новые заявки) и прекращает работу после того, как последняя заявка будет полностью обработана, и все ресурсы будут возвращены.

В процессе программирования обратите внимание на потокобезопасность. Потоки, реализующие обработку ресурсов, работают независимо друг от друга и от сервера ресурсов, поэтому модификация количества оставшихся ресурсов должна производиться с синхронизацией. Используйте synchronized методы для изменения общего количества ресурсов.

Программа должна содержать комментарии по существу работы алгоритма на английском языке!


## Домашнее задание № 2
Двоичное дерево представлено структурой, в которой узлы бывают двух видов: листья и промежуточные узлы. Каждый из типов узлов наследует общему предку Node, в котором определена функция обработки разного вида узлов. Обработка листьев осуществляется функцией типа `Function<V,R>,` получающей на вход значение типа V, хранящееся в узле, и выдающей результат некоторого определенного типа R. Обработка промежуточных узлов осуществляется функцией специального типа
```
@FunctionalInterface
public interface TreeFunction<T,R> {
	R apply(T arg1, R agr2, R arg3);
}
```
которая получает на вход значение, хранящееся в узле, и результаты обработки левого и правого узлов, и также выдает значение типа R. Таким образом, тип данных абстрактного узла будет выглядеть так:
```
public interface Node<V, T> {
	<R> R process(Function<V,R> leafProcessor,
                   TreeFunction<T,R> biNodeProcessor);
}
```
Тип листьев определен следующим образом:
```
public class Leaf<V, T> implements Node<V, T> {
	private V leafInfo;
	public Leaf(V leaf) { leafInfo = leaf; }
	public <R> R process(Function<V,R> leafProcessor,
                          TreeFunction<T,R> biNodeProcessor) {
		return leafProcessor.apply(leafInfo);
	}
}
```
а тип промежуточных узлов так:
```
public class BiNode<V, T> implements Node<V, T> {
	private T binInfo;
	private Node<V, T> left, right;
	
	public BiNode(T info, Node<V, T> left, Node<V, T> right) {
		binInfo = info;
		this.left = left;
		this.right = right;
	}
	
	public <R> R process(Function<V,R> leafProcessor, 
                          TreeFunction<T,R> biNodeProcessor) {
	    R res1 = left.process(leafProcessor, biNodeProcessor);
	    R res2 = right.process(leafProcessor, biNodeProcessor);
	    return biNodeProcessor.apply(binInfo, res1, res2);
	}
}
```
Требуется построить дерево некоторого выражения, листьями которого являются целые числа, а в промежуточных узлах находятся знаки операций '+', '-' или '*', и с помощью метода process написать следующие способы обработки дерева:
вычисление значения выражения;
преобразование дерева в символьную строку;
построение нового дерева, в котором структура остается той же самой, но все значения в листьях инвертированы относительно нуля.

Программа должна содержать комментарии по существу работы алгоритма на английском языке!


## Домашнее задание № 3
В текстовом файле размещена таблица должностей и зарплат сотрудников некоторой фирмы. В каждой строке находятся фамилия, должность и зарплата, разделенные запятыми (считаем, что зарплата указана в целых рублях). Между отдельными полями могут быть пробелы. Пример содержимого файла:



Паниковский, курьер, 15

Бендер-Задунайский, генеральный директор, 200

Балаганов,  секретарь  , 25

Требуется прочитать все данные из файла, разместив их в некотором списке, и написать несколько функций обработки получившегося списка. Сигнатуры требуемых функций:



/** Выдает максимальную зарплату по всем сотрудникам */
```
public static int maxSalary(List<Employee> list) { ... }
```
/** Выдает минимальную зарплату по всем сотрудникам */
```
public static int minSalary(List<Employee> list) { ... }
```
/** Выдает среднюю зарплату по всем сотрудникам */
```
public static double averageSalary(List<Employee> list) { ... }
```
/** Выдает количества сотрудников, находящихся на каждой из должностей */
```
public static Map<String, Integer> jobCount(List<Employee> list)
{ ... }
```
/** Выдает количества сотрудников, распределенные по первым буквам фамилий */
```
public static Map<Character, Integer> abc(List<Employee> list)
{ ... }
```

Программа должна содержать комментарии по существу работы алгоритма на английском языке!

